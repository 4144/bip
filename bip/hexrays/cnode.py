"""
    This file regroup the implementation of the :class:`CNode` object and the
    necessary for defining automatically the inherited class from their
    :class:`HxCItem` equivalent.
"""
from hx_citem import AbstractCItem, HxCType, HxCItem, HxCExpr, HxCStmt

class CNode(AbstractCItem):
    """
        Abstract class which allow to represent C expression and C statement
        decompiled from HexRays. This is an equivalent class to
        :class:`HxCItem` but is designed for visiting an AST generated by
        HexRays. The main advantage to use this class and its subclasses and
        not the :class:`HxCItem` is the additional features which it provides,
        such as:

        * access to the parent node
        * TODO

        .. todo:: complement this list.

        The parrent class :class:`AbstractCItem` also provides common
        functionnality with the :class:`HxCItem` objects.

        .. todo:: precise that all subclasses have the same comportement but
            just with the additional features.
        
        .. todo:: This class does not make use of the ctree_visitor_t provided
            by IDA. (Add to doc if it is actually true).

        This is an abstract class and no object of this class should ever be
        created. The static method :meth:`GetCNode` allow to create object 
        of the correct subclass which inherit from :class:`CNode`.

        .. todo:: document the auto generation of the sublcasses. (in a note
            about implementation details)
    """

    ############################# ITEM CREATION #############################

    def __init__(self, citem, hxcfunc, parent):
        """
            Constructor for the abstract class :class:`HxCItem` . This should
            never be used directly.

            .. todo:: add check for correct types ?

            :param citem: a ``citem_t`` object, in practice this should always
                be a ``cexpr_t`` or a ``cinsn_t`` object.
            :param hxcfunc: A :class:`HxCFunc` object corresponding to the
                function which contains this node/item.
            :param parent: An object which inherit from :class:`CNode`
                corresponding to the parent expression or statement of this
                object. This may be ``None`` if this node is the root of
                the AST tree for its function.
        """
        super(CNode, self).__init__(citem) # provide self._citem
        #: The function associated with this node. This is a :class:`HxCFunc`
        #:  object. This is private and should not be modify. Modifying this
        #:  attribute will not make any modification to the data stored in
        #:  IDA.
        self._hxcfunc = hxcfunc
        #: The parent node of this node. This should be an object which
        #:  inherit from :class:`CNode`. This may be ``None`` if this node
        #:  is the root node of the AST tree for its function. This is private
        #:  and should not be modify. Modifying this
        #:  attribute will not make any modification to the data stored in
        #:  IDA.
        self._parent = parent

    
    def _createChild(self, citem):
        """
            Internal method which allow to create a :class:`CNode` object
            from a ``citem_t`` child of the current node. This must be used
            by :class:`CNodeStmt` and
            :class:`CNodeExpr` for creating their child expression and
            statement. This method is used for having compatibility with
            the :class:`HxCItem` class.

            Internally this function is a wrapper on :meth:`GetCNode` which
            is call with the same function than this object and with this
            object as parent.
    
            :param citem: A ``citem_t`` from ida.
            :return: The equivalent node object to the ``citem_t`` for bip.
                This will be an object which inherit from :class:`CNode` .
        """
        return CNode.GetCNode(citem, self._hxcfunc, self)

    @staticmethod
    def GetCNode(citem, hxcfunc, parent):
        """
            Static method which allow to create an object of the correct child
            class of :class:`CNode` which is equivalent to a ``citem_t`` from
            ida. In particular it will be used for converting ``cexpr_t`` and
            ``cinsn_t`` from ida to :class:`CNodeExpr` and :class:`CNodeStmt`
            in bip.  If no :class:`CNode` child object exist corresponding to
            the ``citem`` provided a ``ValueError`` exception will be raised.
            
            This is the equivalent of :meth:`HxCItem.GetHxCItem` but for the
            :class:`CNode` . 

            .. note:: :class:`CNodeExpr` and :class:`CNodeStmt` should not used
                this function for creating child item but
                :meth:`CNode._createChild`.
    
            .. todo:: maybe return None instead of raising an exception ?
    
            :param citem: A ``citem_t`` from ida.
            :param hxcfunc: A :class:`HxCFunc` object corresponding to the
                function which contains this node/item.
            :param parent: An object which inherit from :class:`CNode`
                corresponding to the parent expression or statement of this
                object. This may be ``None`` if this node is the root of
                the AST tree for its function.
            :return: The equivalent object to the ``citem_t`` for bip. This
                will be an object which inherit from :class:`HxCItem` .
        """
        done = set()
        todo = set(CNode.__subclasses__())
        while len(todo) != 0:
            cl = todo.pop()
            if cl in done:
                continue
            if cl.is_handling_type(citem.op):
                return cl(citem, hxcfunc, parent)
            else:
                done.add(cl)
                todo |= set(cl.__subclasses__())
        raise ValueError("GetCNode could not find an object matching the citem_t type provided ({})".format(citem.op))


    # TODO: implement getter for access to the parent
    # TODO: implement getter for access to the function
    # TODO: implement low and high address ? (map ea from cfunc could may be help ?)
    # TODO: implement find closest address
    # TODO: implement function for making more easy the iterations

class CNodeExpr(CNode):
    """
        Abstract class for representing a C Expression decompiled from
        HexRays. This is an abstract class which is used as a wrapper on top
        of the ``cexpr_t`` object. This is the equivalent of the
        :class:`HxCExpr` class but which inherit from the :class:`CNode` and
        is made for visiting an AST.

        No object of this class should be instanstiated, for getting an
        expression the function :func:`~CNode.GetCNode` should be
        used.

        .. todo:: something better could be done here for avoiding code
            duplication of the :class:`HxCExpr` class.
    """

    def __init__(self, cexpr, hxcfunc, parent):
        """
            Constructor for the :class:`CNodeExpr` object. Arguments are
            used by the :class:`CNode` constructor.

            :param cexpr: A ``cexpr_t`` object from ida.
            :param hxcfunc: A :class:`HxCFunc` object corresponding to the
                function which contains this node/item.
            :param parent: An object which inherit from :class:`CNode`
                corresponding to the parent expression or statement of this
                object. This may be ``None`` if this node is the root of
                the AST tree for its function.
        """
        super(CNodeExpr, self).__init__(cexpr, hxcfunc, parent)
        #: The ``cexpr_t`` object from ida.
        self._cexpr = cexpr

    def __str__(self):
        """
            Surcharge for printing a CExpr
        """
        return "{}(ea=0x{:X}, ops={})".format(self.__class__.__name__, self.ea, self.ops)

    @property
    def ops(self):
        """
            Function which return the C Expressions child of this expression.
            This is used only when the expression is recursive.

            :return: A ``list`` of object inheriting from :class:`CNodeExpr`
                and child of the current expression.
        """
        return []

class CNodeStmt(CNode):
    """
        Abstract class for representing a C Statement as returned by hexrays.
        This is an abstract class which is a wrapper on top of the
        ``cinsn_t`` ida object. This is the equivalent of the
        :class:`HxCStmt` class but which inherit from the :class:`CNode` and
        is made for visiting an AST.

        No object of this class should be instanstiated, for getting an
        expression the function :func:`~CNode.GetCNode` should be
        used.

        A statement can contain one or more child statement and one or more
        child expression (:class:`HxCExpr`) object.
        By convention properties which will return child statement of an
        object will start with the prefix ``st_`` .
    """

    def __init__(self, cinsn, hxcfunc, parent):
        """
            Constructor for a :class:`CNodeStmt` object. Arguments are
            used by the :class:`CNode` constructor.

            :param cinsn: A ``cinsn_t`` from ida.
            :param hxcfunc: A :class:`HxCFunc` object corresponding to the
                function which contains this node/item.
            :param parent: An object which inherit from :class:`CNode`
                corresponding to the parent expression or statement of this
                object. This may be ``None`` if this node is the root of
                the AST tree for its function.
        """
        super(CNodeStmt, self).__init__(cinsn, hxcfunc, parent)
        #: The ``cinsn_t`` object from ida.
        self._cinsn = cinsn

    def __str__(self):
        """
            Surcharge for printing a CStmt.
        """
        return "{}(ea=0x{:X}, st_childs={})".format(self.__class__.__name__, self.ea, self.st_childs)

    @property
    def st_childs(self):
        """
            Property which return a list of the statements which are childs of
            this statement. This is used only when the statement is recursive,
            if not this will return an empty list.

            :return: A list of child statement of this object.
            :rtype: Objects which inherit from :class:`CNodeStmt` .
        """
        return []

    @property
    def expr_childs(self):
        """
            Property which return a list of the expression (:class:`CNodeExpr`)
            which are childs of this statement. This will not return childs
            expression of the statement child of the current object.

            :return: A list of child expression of this object.
            :rtype: Objects which inherit from :class:`CNodeExpr` .
        """
        return []

#: Dictionnary which contain an equivalence between the class which inherit
#:  from :class:`HxCItem` and the one which inherit from :class:`CNode`. This
#:  is used for automatically constructing the classes which inherit from
#:  :class:`CNode` dynamically and should not be modified by hand.
#:  It is initialized with the 3 base classes which have a constructor.
_citem2cnode = {
        HxCItem: CNode,
        HxCExpr: CNodeExpr,
        HxCStmt: CNodeStmt,
    }

def buildCNode(cls):
    """
        Class decorator for automatically building a class equivalent to the
        one pass in argument but which inherit from :class:`CNode` instead
        of :class:`HxCItem` .

        Internally this will:

        * find the equivalent of the base classes by looking
          in ``_citem2cnode`` .
        * create a class identicall to the one in arguments but with name
          change for being prefix by ``CNode`` instead of ``HxC``. Attributes
          of the class are copied into the new class.
        * set the new class created as global to this module (the cnode one,
          not the one it was used in).
    """
    global _citem2cnode
    # check we did not already created it
    if cls in _citem2cnode:
        raise AssertionError("Equivalent class for {} has already been created".format(cls.__name__))

    # start by creating tuples of base classes
    lb = []
    for b in cls.__bases__:
        if b not in _citem2cnode:
            raise AssertionError("Base class for {} does not exist: impossible to generate dynamically".format(cls.__name__))
        lb.append(_citem2cnode[b])

    # creating the dictionnary of attributes
    attr = dict(cls.__dict__) # create a copy of the dict
    attr["__module__"] = __name__ # change module to cnode
    attr["__doc__"] = "Copy of :class:`{}` but which inherit from :class:`CNode`.\nAutomatically created by :func:`~cnode.buildCNode.`".format(cls.__name__)# change doc

    # creating the new class
    cn_cls = type(
            cls.__name__.replace("HxC", "CNode"), # change name
            tuple(lb), # bases classes
            attr
        )

    # adding it to this module
    globals()[cn_cls.__name__] = cn_cls

    # adding it to _citem2cnode
    _citem2cnode[cls] = cn_cls

    # return the old class we don't want to change it
    return cls





